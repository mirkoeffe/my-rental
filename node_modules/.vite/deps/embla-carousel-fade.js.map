{
  "version": 3,
  "sources": ["../../embla-carousel-fade/src/components/utils.ts", "../../embla-carousel-fade/src/components/Fade.ts"],
  "sourcesContent": ["export function clampNumber(number: number, min: number, max: number): number {\n  return Math.min(Math.max(number, min), max)\n}\n\nexport function isNumber(value: number | null): value is number {\n  return typeof value === 'number' && !isNaN(value)\n}\n", "import { OptionsType } from './Options'\nimport { isNumber, clampNumber } from './utils'\nimport {\n  CreatePluginType,\n  EmblaCarouselType,\n  ScrollBodyType\n} from 'embla-carousel'\n\ndeclare module 'embla-carousel' {\n  interface EmblaPluginsType {\n    fade: FadeType\n  }\n}\n\nexport type FadeType = CreatePluginType<{}, OptionsType>\n\nexport type FadeOptionsType = FadeType['options']\n\nfunction Fade(userOptions: FadeOptionsType = {}): FadeType {\n  const fullOpacity = 1\n  const noOpacity = 0\n  const fadeFriction = 0.68\n\n  let emblaApi: EmblaCarouselType\n  let opacities: number[] = []\n  let fadeToNextDistance: number\n  let distanceFromPointerDown = 0\n  let fadeVelocity = 0\n  let progress = 0\n  let shouldFadePair = false\n  let defaultSettledBehaviour: ScrollBodyType['settled']\n  let defaultProgressBehaviour: EmblaCarouselType['scrollProgress']\n\n  function init(emblaApiInstance: EmblaCarouselType): void {\n    emblaApi = emblaApiInstance\n\n    const selectedSnap = emblaApi.selectedScrollSnap()\n    const { scrollBody, containerRect, axis } = emblaApi.internalEngine()\n    const containerSize = axis.measureSize(containerRect)\n\n    fadeToNextDistance = clampNumber(containerSize * 0.75, 200, 500)\n    shouldFadePair = false\n\n    opacities = emblaApi\n      .scrollSnapList()\n      .map((_, index) => (index === selectedSnap ? fullOpacity : noOpacity))\n\n    defaultSettledBehaviour = scrollBody.settled\n    defaultProgressBehaviour = emblaApi.scrollProgress\n\n    scrollBody.settled = settled\n    emblaApi.scrollProgress = scrollProgress\n\n    emblaApi\n      .on('select', select)\n      .on('slideFocus', fadeToSelectedSnapInstantly)\n      .on('pointerDown', pointerDown)\n      .on('pointerUp', pointerUp)\n\n    disableScroll()\n    fadeToSelectedSnapInstantly()\n  }\n\n  function destroy(): void {\n    const { scrollBody } = emblaApi.internalEngine()\n    scrollBody.settled = defaultSettledBehaviour\n    emblaApi.scrollProgress = defaultProgressBehaviour\n\n    emblaApi\n      .off('select', select)\n      .off('slideFocus', fadeToSelectedSnapInstantly)\n      .off('pointerDown', pointerDown)\n      .off('pointerUp', pointerUp)\n\n    emblaApi.slideNodes().forEach((slideNode) => {\n      const slideStyle = slideNode.style\n      slideStyle.opacity = ''\n      slideStyle.transform = ''\n      slideStyle.pointerEvents = ''\n      if (!slideNode.getAttribute('style')) slideNode.removeAttribute('style')\n    })\n  }\n\n  function fadeToSelectedSnapInstantly(): void {\n    const selectedSnap = emblaApi.selectedScrollSnap()\n    setOpacities(selectedSnap, fullOpacity)\n  }\n\n  function pointerUp(): void {\n    shouldFadePair = false\n  }\n\n  function pointerDown(): void {\n    shouldFadePair = false\n    distanceFromPointerDown = 0\n    fadeVelocity = 0\n  }\n\n  function select(): void {\n    const duration = emblaApi.internalEngine().scrollBody.duration()\n    fadeVelocity = duration ? 0 : fullOpacity\n    shouldFadePair = true\n    if (!duration) fadeToSelectedSnapInstantly()\n  }\n\n  function getSlideTransform(position: number): string {\n    const { axis } = emblaApi.internalEngine()\n    const translateAxis = axis.scroll.toUpperCase()\n    return `translate${translateAxis}(${axis.direction(position)}px)`\n  }\n\n  function disableScroll(): void {\n    const { translate, slideLooper } = emblaApi.internalEngine()\n\n    translate.clear()\n    translate.toggleActive(false)\n\n    slideLooper.loopPoints.forEach(({ translate }) => {\n      translate.clear()\n      translate.toggleActive(false)\n    })\n  }\n\n  function lockExcessiveScroll(fadeIndex: number | null): void {\n    const { scrollSnaps, location, target } = emblaApi.internalEngine()\n    if (!isNumber(fadeIndex) || opacities[fadeIndex] < 0.5) return\n\n    location.set(scrollSnaps[fadeIndex])\n    target.set(location)\n  }\n\n  function setOpacities(fadeIndex: number, velocity: number): void {\n    const scrollSnaps = emblaApi.scrollSnapList()\n\n    scrollSnaps.forEach((_, indexA) => {\n      const absVelocity = Math.abs(velocity)\n      const currentOpacity = opacities[indexA]\n      const isFadeIndex = indexA === fadeIndex\n\n      const nextOpacity = isFadeIndex\n        ? currentOpacity + absVelocity\n        : currentOpacity - absVelocity\n\n      const clampedOpacity = clampNumber(nextOpacity, noOpacity, fullOpacity)\n      opacities[indexA] = clampedOpacity\n\n      const fadePair = isFadeIndex && shouldFadePair\n      const indexB = emblaApi.previousScrollSnap()\n\n      if (fadePair) opacities[indexB] = 1 - clampedOpacity\n      if (isFadeIndex) setProgress(fadeIndex, clampedOpacity)\n\n      setOpacity(indexA)\n    })\n  }\n\n  function setOpacity(index: number): void {\n    const slidesInSnap = emblaApi.internalEngine().slideRegistry[index]\n    const { scrollSnaps, containerRect } = emblaApi.internalEngine()\n    const opacity = opacities[index]\n\n    slidesInSnap.forEach((slideIndex) => {\n      const slideStyle = emblaApi.slideNodes()[slideIndex].style\n      const roundedOpacity = parseFloat(opacity.toFixed(2))\n      const hasOpacity = roundedOpacity > noOpacity\n      const position = hasOpacity ? scrollSnaps[index] : containerRect.width + 2\n      const transform = getSlideTransform(position)\n\n      if (hasOpacity) slideStyle.transform = transform\n\n      slideStyle.opacity = roundedOpacity.toString()\n      slideStyle.pointerEvents = opacity > 0.5 ? 'auto' : 'none'\n\n      if (!hasOpacity) slideStyle.transform = transform\n    })\n  }\n\n  function setProgress(fadeIndex: number, opacity: number): void {\n    const { index, dragHandler, scrollSnaps } = emblaApi.internalEngine()\n    const pointerDown = dragHandler.pointerDown()\n    const snapFraction = 1 / (scrollSnaps.length - 1)\n\n    let indexA = fadeIndex\n    let indexB = pointerDown\n      ? emblaApi.selectedScrollSnap()\n      : emblaApi.previousScrollSnap()\n\n    if (pointerDown && indexA === indexB) {\n      const reverseSign = Math.sign(distanceFromPointerDown) * -1\n      indexA = indexB\n      indexB = index.clone().set(indexB).add(reverseSign).get()\n    }\n\n    const currentPosition = indexB * snapFraction\n    const diffPosition = (indexA - indexB) * snapFraction\n    progress = currentPosition + diffPosition * opacity\n  }\n\n  function getFadeIndex(): number | null {\n    const { dragHandler, index, scrollBody } = emblaApi.internalEngine()\n    const selectedSnap = emblaApi.selectedScrollSnap()\n\n    if (!dragHandler.pointerDown()) return selectedSnap\n\n    const directionSign = Math.sign(scrollBody.velocity())\n    const distanceSign = Math.sign(distanceFromPointerDown)\n    const nextSnap = index\n      .clone()\n      .set(selectedSnap)\n      .add(directionSign * -1)\n      .get()\n\n    if (!directionSign || !distanceSign) return null\n    return distanceSign === directionSign ? nextSnap : selectedSnap\n  }\n\n  const fade = (emblaApi: EmblaCarouselType): void => {\n    const { dragHandler, scrollBody } = emblaApi.internalEngine()\n    const pointerDown = dragHandler.pointerDown()\n    const velocity = scrollBody.velocity()\n    const duration = scrollBody.duration()\n    const fadeIndex = getFadeIndex()\n    const noFadeIndex = !isNumber(fadeIndex)\n\n    if (pointerDown) {\n      if (!velocity) return\n\n      distanceFromPointerDown += velocity\n      fadeVelocity = Math.abs(velocity / fadeToNextDistance)\n      lockExcessiveScroll(fadeIndex)\n    }\n\n    if (!pointerDown) {\n      if (!duration || noFadeIndex) return\n\n      fadeVelocity += (fullOpacity - opacities[fadeIndex]) / duration\n      fadeVelocity *= fadeFriction\n    }\n\n    if (noFadeIndex) return\n    setOpacities(fadeIndex, fadeVelocity)\n  }\n\n  function settled(): boolean {\n    const { target, location } = emblaApi.internalEngine()\n    const diffToTarget = target.get() - location.get()\n    const notReachedTarget = Math.abs(diffToTarget) >= 1\n    const fadeIndex = getFadeIndex()\n    const noFadeIndex = !isNumber(fadeIndex)\n\n    fade(emblaApi)\n\n    if (noFadeIndex || notReachedTarget) return false\n    return opacities[fadeIndex] > 0.999\n  }\n\n  function scrollProgress(): number {\n    return progress\n  }\n\n  const self: FadeType = {\n    name: 'fade',\n    options: userOptions,\n    init,\n    destroy\n  }\n  return self\n}\n\ndeclare namespace Fade {\n  let globalOptions: FadeOptionsType | undefined\n}\n\nFade.globalOptions = undefined\n\nexport default Fade\n"],
  "mappings": "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",
  "names": ["clampNumber", "number", "min", "max", "Math", "isNumber", "value", "isNaN", "Fade", "userOptions", "fullOpacity", "noOpacity", "fadeFriction", "emblaApi", "opacities", "fadeToNextDistance", "distanceFromPointerDown", "fadeVelocity", "progress", "shouldFadePair", "defaultSettledBehaviour", "defaultProgressBehaviour", "init", "emblaApiInstance", "selectedSnap", "selectedScrollSnap", "scrollBody", "containerRect", "axis", "internalEngine", "containerSize", "measureSize", "scrollSnapList", "map", "_", "index", "settled", "scrollProgress", "on", "select", "fadeToSelectedSnapInstantly", "pointerDown", "pointerUp", "disableScroll", "destroy", "off", "slideNodes", "forEach", "slideNode", "slideStyle", "style", "opacity", "transform", "pointerEvents", "getAttribute", "removeAttribute", "setOpacities", "duration", "getSlideTransform", "position", "translateAxis", "scroll", "toUpperCase", "direction", "translate", "slideLooper", "clear", "toggleActive", "loopPoints", "lockExcessiveScroll", "fadeIndex", "scrollSnaps", "location", "target", "set", "velocity", "indexA", "absVelocity", "abs", "currentOpacity", "isFadeIndex", "nextOpacity", "clampedOpacity", "fadePair", "indexB", "previousScrollSnap", "setProgress", "setOpacity", "slidesInSnap", "slideRegistry", "slideIndex", "roundedOpacity", "parseFloat", "toFixed", "hasOpacity", "width", "toString", "dragHandler", "snapFraction", "length", "reverseSign", "sign", "clone", "add", "get", "currentPosition", "diffPosition", "getFadeIndex", "directionSign", "distanceSign", "nextSnap", "fade", "noFadeIndex", "diffToTarget", "notReachedTarget", "self", "name", "options", "globalOptions", "undefined"]
}
